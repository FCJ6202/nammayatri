{-# LANGUAGE DeriveAnyClass #-}
{-# LANGUAGE DerivingStrategies #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE UndecidableSuperClasses #-}

module Types.DBSync.DBModel where

import qualified Data.Aeson as A
import qualified Data.List.NonEmpty as NE
import qualified Data.Serialize as Serialize
import qualified Data.Text as T
import Database.Beam.Postgres (Postgres)
import EulerHS.KVConnector.Types (MeshMeta)
import Kernel.Prelude
import qualified Sequelize
import qualified "rider-app" Storage.Beam.AppInstalls as AppInstalls
import qualified "rider-app" Storage.Beam.BlackListOrg as BlackListOrg
import qualified "rider-app" Storage.Beam.Booking as Booking

availableDBModels :: NE.NonEmpty DBModel
availableDBModels = fromMaybe (pure minBound) $ NE.nonEmpty [minBound .. maxBound]

type TableK = (Type -> Type) -> Type

class
  ( Sequelize.Model Postgres table,
    Show (table Identity),
    FromJSON (table Identity),
    ToJSON (table Identity),
    MeshMeta Postgres table,
    Serialize.Serialize (table Identity)
  ) =>
  IsDbTable (table :: (Type -> Type) -> Type)

instance IsDbTable AppInstalls.AppInstallsT

instance IsDbTable BlackListOrg.BlackListOrgT

instance IsDbTable Booking.BookingT

withDBObjectContent_ ::
  forall (f :: TableK -> Type) (res :: Type).
  DBObject f ->
  (forall t. IsDbTable t => f t -> res) ->
  res
withDBObjectContent_ dbObject action = withDBObjectContent dbObject (const action)

newtype DBModelOptions = DBModelOptions {getDBModel :: DBModel}

instance FromJSON DBModelOptions where
  parseJSON = A.withText "DBModelOptions" $ \options -> case dropSuffix "Options" options of
    Nothing -> fail $ T.unpack ("Expected a DBModelOptions but got '" <> options <> "'")
    Just model -> parseJSON (A.String model)

-- dropSuffix "tableOptions" = Just "table"
dropSuffix :: Text -> Text -> Maybe Text
dropSuffix suffix str = do
  let l = T.length str - T.length suffix
  if T.drop l str == suffix then Just $ T.take l str else Nothing

-- Autogenerated code example for three tables:

data DBModel = AppInstalls | BlackListOrg | Booking
  deriving stock (Show, Read, Enum, Bounded, Generic)
  deriving anyclass (FromJSON)

data DBObject (f :: TableK -> Type)
  = AppInstallsObject (f AppInstalls.AppInstallsT)
  | BlackListOrgObject (f BlackListOrg.BlackListOrgT)
  | BookingObject (f Booking.BookingT)
  deriving (Generic)

-- FIXME we can use IsDBTable instance, so no need to pass DBModel
withDBObjectContent ::
  forall (f :: TableK -> Type) (res :: Type).
  DBObject f ->
  (forall t. IsDbTable t => DBModel -> f t -> res) ->
  res
withDBObjectContent dbObject action = do
  case dbObject of
    AppInstallsObject obj -> action @AppInstalls.AppInstallsT AppInstalls obj
    BlackListOrgObject obj -> action @BlackListOrg.BlackListOrgT BlackListOrg obj
    BookingObject obj -> action @Booking.BookingT Booking obj

buildDBObject ::
  forall (f :: TableK -> Type) (m :: Type -> Type).
  Functor m =>
  DBModel ->
  (forall t. IsDbTable t => m (f t)) ->
  m (DBObject f)
buildDBObject dbModel tableAction = case dbModel of
  AppInstalls -> AppInstallsObject <$> (tableAction @AppInstalls.AppInstallsT)
  BlackListOrg -> BlackListOrgObject <$> (tableAction @BlackListOrg.BlackListOrgT)
  Booking -> BookingObject <$> (tableAction @Booking.BookingT)

withFilteredDBObjectContent ::
  forall (f :: TableK -> Type) (res :: Type) (payload :: Type).
  DBModel ->
  [(DBObject f, payload)] ->
  (forall t. IsDbTable t => [(f t, payload)] -> res) ->
  res
withFilteredDBObjectContent dbModel dbObjectsWithPayload action = do
  case dbModel of
    AppInstalls -> action @AppInstalls.AppInstallsT [(obj, payload) | (AppInstallsObject obj, payload) <- dbObjectsWithPayload]
    BlackListOrg -> action @BlackListOrg.BlackListOrgT [(obj, payload) | (BlackListOrgObject obj, payload) <- dbObjectsWithPayload]
    Booking -> action @Booking.BookingT [(obj, payload) | (BookingObject obj, payload) <- dbObjectsWithPayload]
