-- File auto generated by servant-purescript! --
module ServerAPI where

import Prelude

import Beckn.Types.API.Blacklist (CreateReq, CreateRes, ListRes, UpdateReq, UpdateRes)
import Beckn.Types.API.Comment (CreateReq, CreateRes, ListRes)
import Beckn.Types.API.Customer (GetCustomerRes)
import Beckn.Types.API.Document (DocumentRes, ListDocumentRes)
import Beckn.Types.API.Organization (CreateOrganizationReq, ListOrganizationRes, OrganizationRes, UpdateOrganizationReq)
import Beckn.Types.API.Pass (ListPassRes, PassRes, UpdatePassReq)
import Beckn.Types.API.PassApplication (CreatePassApplicationReq, ListPassApplicationRes, PassApplicationRes, UpdatePassApplicationReq)
import Beckn.Types.API.Quota (CreateReq, CreateRes, ListRes, UpdateReq, UpdateRes)
import Beckn.Types.API.Registration (InitiateLoginReq, InitiateLoginRes, LoginReq, LoginRes, ReInitiateLoginReq)
import Beckn.Types.API.Tag (CreateReq, CreateRes, ListRes, TagEntityReq, TagEntityRes)
import Beckn.Types.API.User (CreateReq, CreateRes, ListRes, UpdateReq, UpdateRes)
import Beckn.Types.App (BlacklistId, OrganizationId, PassApplicationId, QuotaId, UserId)
import Beckn.Types.Common (Ack, DocumentByType, DocumentEntity, EntityType, LocationType, PassIDType, PassType)
import Beckn.Types.Storage.Blacklist (BlacklistT)
import Beckn.Types.Storage.Organization (Status)
import Beckn.Types.Storage.PassApplication (Status)
import Beckn.Types.Storage.Quota (QuotaT)
import Beckn.Types.Storage.User (UserT)
import Control.Monad.Aff.Class (class MonadAff)
import Control.Monad.Error.Class (class MonadError)
import Control.Monad.Reader.Class (ask, class MonadAsk)
import Data.Argonaut.Core (stringify)
import Data.Array (catMaybes, null)
import Data.Functor.Identity (Identity)
import Data.Maybe (Maybe, Maybe(..))
import Data.Nullable (toNullable)
import Data.String (joinWith)
import Network.HTTP.Affjax (AJAX)
import Prim (Array, Boolean, Int, String)
import Servant.Multipart (Mem, MultipartData)
import Servant.PureScript.Affjax (AjaxError, affjax, defaultRequest)
import Servant.PureScript.Settings (SPSettingsDecodeJson_(..), SPSettingsEncodeJson_(..), SPSettings_(..), gDefaultToURLPiece)
import Servant.PureScript.Util (encodeHeader, encodeListQuery, encodeQueryItem, encodeURLPiece, getResult)

newtype SPParams_ = SPParams_ { baseURL :: String
                              }

getV1 :: forall eff m.
         MonadAsk (SPSettings_ SPParams_) m => MonadError AjaxError m => MonadAff ( ajax :: AJAX | eff) m
         => m String
getV1 = do
  spOpts_' <- ask
  let spOpts_ = case spOpts_' of SPSettings_ o -> o
  let spParams_ = case spOpts_.params of SPParams_ ps_ -> ps_
  let baseURL = spParams_.baseURL
  let httpMethod = "GET"
  let queryString = ""
  let reqUrl = baseURL <> "v1" <> queryString
  let reqHeaders =
        []
  let affReq = defaultRequest
                 { method = httpMethod
                 , url = reqUrl
                 , headers = defaultRequest.headers <> reqHeaders
                 }
  affResp <- affjax affReq
  let decodeJson = case spOpts_.decodeJson of SPSettingsDecodeJson_ d -> d
  getResult affReq decodeJson affResp

postV1Token :: forall eff m.
               MonadAsk (SPSettings_ SPParams_) m => MonadError AjaxError m => MonadAff ( ajax :: AJAX | eff) m
               => InitiateLoginReq -> m InitiateLoginRes
postV1Token reqBody = do
  spOpts_' <- ask
  let spOpts_ = case spOpts_' of SPSettings_ o -> o
  let spParams_ = case spOpts_.params of SPParams_ ps_ -> ps_
  let baseURL = spParams_.baseURL
  let httpMethod = "POST"
  let queryString = ""
  let reqUrl = baseURL <> "v1" <> "/" <> "token" <> queryString
  let reqHeaders =
        []
  let encodeJson = case spOpts_.encodeJson of SPSettingsEncodeJson_ e -> e
  let affReq = defaultRequest
                 { method = httpMethod
                 , url = reqUrl
                 , headers = defaultRequest.headers <> reqHeaders
                 , content = toNullable <<< Just <<< stringify <<< encodeJson $ reqBody
                 }
  affResp <- affjax affReq
  let decodeJson = case spOpts_.decodeJson of SPSettingsDecodeJson_ d -> d
  getResult affReq decodeJson affResp

postV1TokenByTokenIdVerify :: forall eff m.
                              MonadAsk (SPSettings_ SPParams_) m => MonadError AjaxError m => MonadAff ( ajax :: AJAX | eff) m
                              => LoginReq -> String -> m LoginRes
postV1TokenByTokenIdVerify reqBody tokenId = do
  spOpts_' <- ask
  let spOpts_ = case spOpts_' of SPSettings_ o -> o
  let spParams_ = case spOpts_.params of SPParams_ ps_ -> ps_
  let baseURL = spParams_.baseURL
  let httpMethod = "POST"
  let queryString = ""
  let reqUrl = baseURL <> "v1" <> "/" <> "token"
        <> "/" <> encodeURLPiece spOpts_' tokenId
        <> "/" <> "verify" <> queryString
  let reqHeaders =
        []
  let encodeJson = case spOpts_.encodeJson of SPSettingsEncodeJson_ e -> e
  let affReq = defaultRequest
                 { method = httpMethod
                 , url = reqUrl
                 , headers = defaultRequest.headers <> reqHeaders
                 , content = toNullable <<< Just <<< stringify <<< encodeJson $ reqBody
                 }
  affResp <- affjax affReq
  let decodeJson = case spOpts_.decodeJson of SPSettingsDecodeJson_ d -> d
  getResult affReq decodeJson affResp

postV1TokenByTokenIdResend :: forall eff m.
                              MonadAsk (SPSettings_ SPParams_) m => MonadError AjaxError m => MonadAff ( ajax :: AJAX | eff) m
                              => ReInitiateLoginReq -> String
                              -> m InitiateLoginRes
postV1TokenByTokenIdResend reqBody tokenId = do
  spOpts_' <- ask
  let spOpts_ = case spOpts_' of SPSettings_ o -> o
  let spParams_ = case spOpts_.params of SPParams_ ps_ -> ps_
  let baseURL = spParams_.baseURL
  let httpMethod = "POST"
  let queryString = ""
  let reqUrl = baseURL <> "v1" <> "/" <> "token"
        <> "/" <> encodeURLPiece spOpts_' tokenId
        <> "/" <> "resend" <> queryString
  let reqHeaders =
        []
  let encodeJson = case spOpts_.encodeJson of SPSettingsEncodeJson_ e -> e
  let affReq = defaultRequest
                 { method = httpMethod
                 , url = reqUrl
                 , headers = defaultRequest.headers <> reqHeaders
                 , content = toNullable <<< Just <<< stringify <<< encodeJson $ reqBody
                 }
  affResp <- affjax affReq
  let decodeJson = case spOpts_.decodeJson of SPSettingsDecodeJson_ d -> d
  getResult affReq decodeJson affResp

postV1Pass_application :: forall eff m.
                          MonadAsk (SPSettings_ SPParams_) m => MonadError AjaxError m => MonadAff ( ajax :: AJAX | eff) m
                          => Maybe String -> CreatePassApplicationReq
                          -> m PassApplicationRes
postV1Pass_application registrationToken reqBody = do
  spOpts_' <- ask
  let spOpts_ = case spOpts_' of SPSettings_ o -> o
  let spParams_ = case spOpts_.params of SPParams_ ps_ -> ps_
  let baseURL = spParams_.baseURL
  let httpMethod = "POST"
  let queryString = ""
  let reqUrl = baseURL <> "v1" <> "/" <> "pass_application" <> queryString
  let reqHeaders =
        [{ field : "registrationToken"
         , value : encodeHeader spOpts_' registrationToken
         }]
  let encodeJson = case spOpts_.encodeJson of SPSettingsEncodeJson_ e -> e
  let affReq = defaultRequest
                 { method = httpMethod
                 , url = reqUrl
                 , headers = defaultRequest.headers <> reqHeaders
                 , content = toNullable <<< Just <<< stringify <<< encodeJson $ reqBody
                 }
  affResp <- affjax affReq
  let decodeJson = case spOpts_.decodeJson of SPSettingsDecodeJson_ d -> d
  getResult affReq decodeJson affResp

getV1Pass_applicationList :: forall eff m.
                             MonadAsk (SPSettings_ SPParams_) m => MonadError AjaxError m => MonadAff ( ajax :: AJAX | eff) m
                             => Maybe String -> Maybe (Maybe Int)
                             -> Maybe (Maybe Int) -> Array Int -> Array String
                             -> Array String -> Array String -> Array String
                             -> Array Int -> Array String -> Array String
                             -> Array String -> Array String -> Array Status
                             -> Array OrganizationId -> Array PassType
                             -> m ListPassApplicationRes
getV1Pass_applicationList registrationToken limit offset from_pincode from_city
                          from_district from_ward from_state to_pincode to_city
                          to_district to_ward to_state status organization
                          type = do
  spOpts_' <- ask
  let spOpts_ = case spOpts_' of SPSettings_ o -> o
  let spParams_ = case spOpts_.params of SPParams_ ps_ -> ps_
  let baseURL = spParams_.baseURL
  let httpMethod = "GET"
  let queryArgs = catMaybes [
    encodeQueryItem spOpts_' "limit" <$> limit,
    encodeQueryItem spOpts_' "offset" <$> offset,
    encodeListQuery spOpts_' "from_pincode" <$> Just from_pincode,
    encodeListQuery spOpts_' "from_city" <$> Just from_city,
    encodeListQuery spOpts_' "from_district" <$> Just from_district,
    encodeListQuery spOpts_' "from_ward" <$> Just from_ward,
    encodeListQuery spOpts_' "from_state" <$> Just from_state,
    encodeListQuery spOpts_' "to_pincode" <$> Just to_pincode,
    encodeListQuery spOpts_' "to_city" <$> Just to_city,
    encodeListQuery spOpts_' "to_district" <$> Just to_district,
    encodeListQuery spOpts_' "to_ward" <$> Just to_ward,
    encodeListQuery spOpts_' "to_state" <$> Just to_state,
    encodeListQuery spOpts_' "status" <$> Just status,
    encodeListQuery spOpts_' "organization" <$> Just organization,
    encodeListQuery spOpts_' "type" <$> Just type
  ]
  let queryString = if null queryArgs then "" else "?" <> (joinWith "&" queryArgs)
  let reqUrl = baseURL <> "v1" <> "/" <> "pass_application"
        <> "/" <> "list" <> queryString
  let reqHeaders =
        [{ field : "registrationToken"
         , value : encodeHeader spOpts_' registrationToken
         }]
  let affReq = defaultRequest
                 { method = httpMethod
                 , url = reqUrl
                 , headers = defaultRequest.headers <> reqHeaders
                 }
  affResp <- affjax affReq
  let decodeJson = case spOpts_.decodeJson of SPSettingsDecodeJson_ d -> d
  getResult affReq decodeJson affResp

getV1Pass_applicationByPassApplicationId :: forall eff m.
                                            MonadAsk (SPSettings_ SPParams_) m => MonadError AjaxError m => MonadAff ( ajax :: AJAX | eff) m
                                            => Maybe String -> PassApplicationId
                                            -> m PassApplicationRes
getV1Pass_applicationByPassApplicationId registrationToken
                                         passApplicationId = do
  spOpts_' <- ask
  let spOpts_ = case spOpts_' of SPSettings_ o -> o
  let spParams_ = case spOpts_.params of SPParams_ ps_ -> ps_
  let baseURL = spParams_.baseURL
  let httpMethod = "GET"
  let queryString = ""
  let reqUrl = baseURL <> "v1" <> "/" <> "pass_application"
        <> "/" <> encodeURLPiece spOpts_' passApplicationId <> queryString
  let reqHeaders =
        [{ field : "registrationToken"
         , value : encodeHeader spOpts_' registrationToken
         }]
  let affReq = defaultRequest
                 { method = httpMethod
                 , url = reqUrl
                 , headers = defaultRequest.headers <> reqHeaders
                 }
  affResp <- affjax affReq
  let decodeJson = case spOpts_.decodeJson of SPSettingsDecodeJson_ d -> d
  getResult affReq decodeJson affResp

postV1Pass_applicationByPassApplicationId :: forall eff m.
                                             MonadAsk (SPSettings_ SPParams_) m => MonadError AjaxError m => MonadAff ( ajax :: AJAX | eff) m
                                             => Maybe String
                                             -> UpdatePassApplicationReq
                                             -> PassApplicationId
                                             -> m PassApplicationRes
postV1Pass_applicationByPassApplicationId registrationToken reqBody
                                          passApplicationId = do
  spOpts_' <- ask
  let spOpts_ = case spOpts_' of SPSettings_ o -> o
  let spParams_ = case spOpts_.params of SPParams_ ps_ -> ps_
  let baseURL = spParams_.baseURL
  let httpMethod = "POST"
  let queryString = ""
  let reqUrl = baseURL <> "v1" <> "/" <> "pass_application"
        <> "/" <> encodeURLPiece spOpts_' passApplicationId <> queryString
  let reqHeaders =
        [{ field : "registrationToken"
         , value : encodeHeader spOpts_' registrationToken
         }]
  let encodeJson = case spOpts_.encodeJson of SPSettingsEncodeJson_ e -> e
  let affReq = defaultRequest
                 { method = httpMethod
                 , url = reqUrl
                 , headers = defaultRequest.headers <> reqHeaders
                 , content = toNullable <<< Just <<< stringify <<< encodeJson $ reqBody
                 }
  affResp <- affjax affReq
  let decodeJson = case spOpts_.decodeJson of SPSettingsDecodeJson_ d -> d
  getResult affReq decodeJson affResp

postV1Organization :: forall eff m.
                      MonadAsk (SPSettings_ SPParams_) m => MonadError AjaxError m => MonadAff ( ajax :: AJAX | eff) m
                      => Maybe String -> CreateOrganizationReq
                      -> m OrganizationRes
postV1Organization registrationToken reqBody = do
  spOpts_' <- ask
  let spOpts_ = case spOpts_' of SPSettings_ o -> o
  let spParams_ = case spOpts_.params of SPParams_ ps_ -> ps_
  let baseURL = spParams_.baseURL
  let httpMethod = "POST"
  let queryString = ""
  let reqUrl = baseURL <> "v1" <> "/" <> "organization" <> queryString
  let reqHeaders =
        [{ field : "registrationToken"
         , value : encodeHeader spOpts_' registrationToken
         }]
  let encodeJson = case spOpts_.encodeJson of SPSettingsEncodeJson_ e -> e
  let affReq = defaultRequest
                 { method = httpMethod
                 , url = reqUrl
                 , headers = defaultRequest.headers <> reqHeaders
                 , content = toNullable <<< Just <<< stringify <<< encodeJson $ reqBody
                 }
  affResp <- affjax affReq
  let decodeJson = case spOpts_.decodeJson of SPSettingsDecodeJson_ d -> d
  getResult affReq decodeJson affResp

getV1OrganizationList :: forall eff m.
                         MonadAsk (SPSettings_ SPParams_) m => MonadError AjaxError m => MonadAff ( ajax :: AJAX | eff) m
                         => Maybe String -> Maybe (Maybe Int)
                         -> Maybe (Maybe Int) -> Array LocationType -> Array Int
                         -> Array String -> Array String -> Array String
                         -> Array String -> Array Status
                         -> Maybe (Maybe Boolean) -> m ListOrganizationRes
getV1OrganizationList registrationToken limit offset locationType pincode city
                      district ward state status verified = do
  spOpts_' <- ask
  let spOpts_ = case spOpts_' of SPSettings_ o -> o
  let spParams_ = case spOpts_.params of SPParams_ ps_ -> ps_
  let baseURL = spParams_.baseURL
  let httpMethod = "GET"
  let queryArgs = catMaybes [
    encodeQueryItem spOpts_' "limit" <$> limit,
    encodeQueryItem spOpts_' "offset" <$> offset,
    encodeListQuery spOpts_' "locationType" <$> Just locationType,
    encodeListQuery spOpts_' "pincode" <$> Just pincode,
    encodeListQuery spOpts_' "city" <$> Just city,
    encodeListQuery spOpts_' "district" <$> Just district,
    encodeListQuery spOpts_' "ward" <$> Just ward,
    encodeListQuery spOpts_' "state" <$> Just state,
    encodeListQuery spOpts_' "status" <$> Just status,
    encodeQueryItem spOpts_' "verified" <$> verified
  ]
  let queryString = if null queryArgs then "" else "?" <> (joinWith "&" queryArgs)
  let reqUrl = baseURL <> "v1" <> "/" <> "organization"
        <> "/" <> "list" <> queryString
  let reqHeaders =
        [{ field : "registrationToken"
         , value : encodeHeader spOpts_' registrationToken
         }]
  let affReq = defaultRequest
                 { method = httpMethod
                 , url = reqUrl
                 , headers = defaultRequest.headers <> reqHeaders
                 }
  affResp <- affjax affReq
  let decodeJson = case spOpts_.decodeJson of SPSettingsDecodeJson_ d -> d
  getResult affReq decodeJson affResp

getV1OrganizationByOrganizationId :: forall eff m.
                                     MonadAsk (SPSettings_ SPParams_) m => MonadError AjaxError m => MonadAff ( ajax :: AJAX | eff) m
                                     => Maybe String -> String
                                     -> m OrganizationRes
getV1OrganizationByOrganizationId registrationToken organizationId = do
  spOpts_' <- ask
  let spOpts_ = case spOpts_' of SPSettings_ o -> o
  let spParams_ = case spOpts_.params of SPParams_ ps_ -> ps_
  let baseURL = spParams_.baseURL
  let httpMethod = "GET"
  let queryString = ""
  let reqUrl = baseURL <> "v1" <> "/" <> "organization"
        <> "/" <> encodeURLPiece spOpts_' organizationId <> queryString
  let reqHeaders =
        [{ field : "registrationToken"
         , value : encodeHeader spOpts_' registrationToken
         }]
  let affReq = defaultRequest
                 { method = httpMethod
                 , url = reqUrl
                 , headers = defaultRequest.headers <> reqHeaders
                 }
  affResp <- affjax affReq
  let decodeJson = case spOpts_.decodeJson of SPSettingsDecodeJson_ d -> d
  getResult affReq decodeJson affResp

postV1OrganizationByOrganizationId :: forall eff m.
                                      MonadAsk (SPSettings_ SPParams_) m => MonadError AjaxError m => MonadAff ( ajax :: AJAX | eff) m
                                      => Maybe String -> UpdateOrganizationReq
                                      -> String -> m OrganizationRes
postV1OrganizationByOrganizationId registrationToken reqBody organizationId = do
  spOpts_' <- ask
  let spOpts_ = case spOpts_' of SPSettings_ o -> o
  let spParams_ = case spOpts_.params of SPParams_ ps_ -> ps_
  let baseURL = spParams_.baseURL
  let httpMethod = "POST"
  let queryString = ""
  let reqUrl = baseURL <> "v1" <> "/" <> "organization"
        <> "/" <> encodeURLPiece spOpts_' organizationId <> queryString
  let reqHeaders =
        [{ field : "registrationToken"
         , value : encodeHeader spOpts_' registrationToken
         }]
  let encodeJson = case spOpts_.encodeJson of SPSettingsEncodeJson_ e -> e
  let affReq = defaultRequest
                 { method = httpMethod
                 , url = reqUrl
                 , headers = defaultRequest.headers <> reqHeaders
                 , content = toNullable <<< Just <<< stringify <<< encodeJson $ reqBody
                 }
  affResp <- affjax affReq
  let decodeJson = case spOpts_.decodeJson of SPSettingsDecodeJson_ d -> d
  getResult affReq decodeJson affResp

getV1CustomerByCustomerId :: forall eff m.
                             MonadAsk (SPSettings_ SPParams_) m => MonadError AjaxError m => MonadAff ( ajax :: AJAX | eff) m
                             => Maybe String -> String -> m GetCustomerRes
getV1CustomerByCustomerId registrationToken customerId = do
  spOpts_' <- ask
  let spOpts_ = case spOpts_' of SPSettings_ o -> o
  let spParams_ = case spOpts_.params of SPParams_ ps_ -> ps_
  let baseURL = spParams_.baseURL
  let httpMethod = "GET"
  let queryString = ""
  let reqUrl = baseURL <> "v1" <> "/" <> "customer"
        <> "/" <> encodeURLPiece spOpts_' customerId <> queryString
  let reqHeaders =
        [{ field : "registrationToken"
         , value : encodeHeader spOpts_' registrationToken
         }]
  let affReq = defaultRequest
                 { method = httpMethod
                 , url = reqUrl
                 , headers = defaultRequest.headers <> reqHeaders
                 }
  affResp <- affjax affReq
  let decodeJson = case spOpts_.decodeJson of SPSettingsDecodeJson_ d -> d
  getResult affReq decodeJson affResp

getV1PassByPassId :: forall eff m.
                     MonadAsk (SPSettings_ SPParams_) m => MonadError AjaxError m => MonadAff ( ajax :: AJAX | eff) m
                     => Maybe String -> String -> m PassRes
getV1PassByPassId registrationToken passId = do
  spOpts_' <- ask
  let spOpts_ = case spOpts_' of SPSettings_ o -> o
  let spParams_ = case spOpts_.params of SPParams_ ps_ -> ps_
  let baseURL = spParams_.baseURL
  let httpMethod = "GET"
  let queryString = ""
  let reqUrl = baseURL <> "v1" <> "/" <> "pass"
        <> "/" <> encodeURLPiece spOpts_' passId <> queryString
  let reqHeaders =
        [{ field : "registrationToken"
         , value : encodeHeader spOpts_' registrationToken
         }]
  let affReq = defaultRequest
                 { method = httpMethod
                 , url = reqUrl
                 , headers = defaultRequest.headers <> reqHeaders
                 }
  affResp <- affjax affReq
  let decodeJson = case spOpts_.decodeJson of SPSettingsDecodeJson_ d -> d
  getResult affReq decodeJson affResp

postV1PassByPassId :: forall eff m.
                      MonadAsk (SPSettings_ SPParams_) m => MonadError AjaxError m => MonadAff ( ajax :: AJAX | eff) m
                      => Maybe String -> UpdatePassReq -> String -> m PassRes
postV1PassByPassId registrationToken reqBody passId = do
  spOpts_' <- ask
  let spOpts_ = case spOpts_' of SPSettings_ o -> o
  let spParams_ = case spOpts_.params of SPParams_ ps_ -> ps_
  let baseURL = spParams_.baseURL
  let httpMethod = "POST"
  let queryString = ""
  let reqUrl = baseURL <> "v1" <> "/" <> "pass"
        <> "/" <> encodeURLPiece spOpts_' passId <> queryString
  let reqHeaders =
        [{ field : "registrationToken"
         , value : encodeHeader spOpts_' registrationToken
         }]
  let encodeJson = case spOpts_.encodeJson of SPSettingsEncodeJson_ e -> e
  let affReq = defaultRequest
                 { method = httpMethod
                 , url = reqUrl
                 , headers = defaultRequest.headers <> reqHeaders
                 , content = toNullable <<< Just <<< stringify <<< encodeJson $ reqBody
                 }
  affResp <- affjax affReq
  let decodeJson = case spOpts_.decodeJson of SPSettingsDecodeJson_ d -> d
  getResult affReq decodeJson affResp

getV1PassList :: forall eff m.
                 MonadAsk (SPSettings_ SPParams_) m => MonadError AjaxError m => MonadAff ( ajax :: AJAX | eff) m
                 => Maybe String -> Maybe PassIDType -> Maybe String
                 -> Maybe (Maybe Int) -> Maybe (Maybe Int) -> Maybe PassType
                 -> m ListPassRes
getV1PassList registrationToken identifierType identifier limit offset type = do
  spOpts_' <- ask
  let spOpts_ = case spOpts_' of SPSettings_ o -> o
  let spParams_ = case spOpts_.params of SPParams_ ps_ -> ps_
  let baseURL = spParams_.baseURL
  let httpMethod = "GET"
  let queryArgs = catMaybes [
    encodeQueryItem spOpts_' "identifierType" <$> identifierType,
    encodeQueryItem spOpts_' "identifier" <$> identifier,
    encodeQueryItem spOpts_' "limit" <$> limit,
    encodeQueryItem spOpts_' "offset" <$> offset,
    encodeQueryItem spOpts_' "type" <$> type
  ]
  let queryString = if null queryArgs then "" else "?" <> (joinWith "&" queryArgs)
  let reqUrl = baseURL <> "v1" <> "/" <> "pass" <> "/" <> "list" <> queryString
  let reqHeaders =
        [{ field : "registrationToken"
         , value : encodeHeader spOpts_' registrationToken
         }]
  let affReq = defaultRequest
                 { method = httpMethod
                 , url = reqUrl
                 , headers = defaultRequest.headers <> reqHeaders
                 }
  affResp <- affjax affReq
  let decodeJson = case spOpts_.decodeJson of SPSettingsDecodeJson_ d -> d
  getResult affReq decodeJson affResp

postV1User :: forall eff m.
              MonadAsk (SPSettings_ SPParams_) m => MonadError AjaxError m => MonadAff ( ajax :: AJAX | eff) m
              => Maybe String -> CreateReq -> m CreateRes
postV1User registrationToken reqBody = do
  spOpts_' <- ask
  let spOpts_ = case spOpts_' of SPSettings_ o -> o
  let spParams_ = case spOpts_.params of SPParams_ ps_ -> ps_
  let baseURL = spParams_.baseURL
  let httpMethod = "POST"
  let queryString = ""
  let reqUrl = baseURL <> "v1" <> "/" <> "user" <> queryString
  let reqHeaders =
        [{ field : "registrationToken"
         , value : encodeHeader spOpts_' registrationToken
         }]
  let encodeJson = case spOpts_.encodeJson of SPSettingsEncodeJson_ e -> e
  let affReq = defaultRequest
                 { method = httpMethod
                 , url = reqUrl
                 , headers = defaultRequest.headers <> reqHeaders
                 , content = toNullable <<< Just <<< stringify <<< encodeJson $ reqBody
                 }
  affResp <- affjax affReq
  let decodeJson = case spOpts_.decodeJson of SPSettingsDecodeJson_ d -> d
  getResult affReq decodeJson affResp

putV1UserByUserId :: forall eff m.
                     MonadAsk (SPSettings_ SPParams_) m => MonadError AjaxError m => MonadAff ( ajax :: AJAX | eff) m
                     => Maybe String -> UpdateReq -> UserId -> m UpdateRes
putV1UserByUserId registrationToken reqBody userId = do
  spOpts_' <- ask
  let spOpts_ = case spOpts_' of SPSettings_ o -> o
  let spParams_ = case spOpts_.params of SPParams_ ps_ -> ps_
  let baseURL = spParams_.baseURL
  let httpMethod = "PUT"
  let queryString = ""
  let reqUrl = baseURL <> "v1" <> "/" <> "user"
        <> "/" <> encodeURLPiece spOpts_' userId <> queryString
  let reqHeaders =
        [{ field : "registrationToken"
         , value : encodeHeader spOpts_' registrationToken
         }]
  let encodeJson = case spOpts_.encodeJson of SPSettingsEncodeJson_ e -> e
  let affReq = defaultRequest
                 { method = httpMethod
                 , url = reqUrl
                 , headers = defaultRequest.headers <> reqHeaders
                 , content = toNullable <<< Just <<< stringify <<< encodeJson $ reqBody
                 }
  affResp <- affjax affReq
  let decodeJson = case spOpts_.decodeJson of SPSettingsDecodeJson_ d -> d
  getResult affReq decodeJson affResp

getV1UserList :: forall eff m.
                 MonadAsk (SPSettings_ SPParams_) m => MonadError AjaxError m => MonadAff ( ajax :: AJAX | eff) m
                 => Maybe String -> Maybe (Maybe Int) -> Maybe (Maybe Int)
                 -> m ListRes
getV1UserList registrationToken limit offset = do
  spOpts_' <- ask
  let spOpts_ = case spOpts_' of SPSettings_ o -> o
  let spParams_ = case spOpts_.params of SPParams_ ps_ -> ps_
  let baseURL = spParams_.baseURL
  let httpMethod = "GET"
  let queryArgs = catMaybes [
    encodeQueryItem spOpts_' "limit" <$> limit,
    encodeQueryItem spOpts_' "offset" <$> offset
  ]
  let queryString = if null queryArgs then "" else "?" <> (joinWith "&" queryArgs)
  let reqUrl = baseURL <> "v1" <> "/" <> "user" <> "/" <> "list" <> queryString
  let reqHeaders =
        [{ field : "registrationToken"
         , value : encodeHeader spOpts_' registrationToken
         }]
  let affReq = defaultRequest
                 { method = httpMethod
                 , url = reqUrl
                 , headers = defaultRequest.headers <> reqHeaders
                 }
  affResp <- affjax affReq
  let decodeJson = case spOpts_.decodeJson of SPSettingsDecodeJson_ d -> d
  getResult affReq decodeJson affResp

getV1UserBy:id :: forall eff m.
                  MonadAsk (SPSettings_ SPParams_) m => MonadError AjaxError m => MonadAff ( ajax :: AJAX | eff) m
                  => Maybe String -> UserId -> m (UserT Identity)
getV1UserBy:id registrationToken _id = do
  spOpts_' <- ask
  let spOpts_ = case spOpts_' of SPSettings_ o -> o
  let spParams_ = case spOpts_.params of SPParams_ ps_ -> ps_
  let baseURL = spParams_.baseURL
  let httpMethod = "GET"
  let queryString = ""
  let reqUrl = baseURL <> "v1" <> "/" <> "user"
        <> "/" <> encodeURLPiece spOpts_' _id <> queryString
  let reqHeaders =
        [{ field : "registrationToken"
         , value : encodeHeader spOpts_' registrationToken
         }]
  let affReq = defaultRequest
                 { method = httpMethod
                 , url = reqUrl
                 , headers = defaultRequest.headers <> reqHeaders
                 }
  affResp <- affjax affReq
  let decodeJson = case spOpts_.decodeJson of SPSettingsDecodeJson_ d -> d
  getResult affReq decodeJson affResp

deleteV1UserBy:id :: forall eff m.
                     MonadAsk (SPSettings_ SPParams_) m => MonadError AjaxError m => MonadAff ( ajax :: AJAX | eff) m
                     => Maybe String -> UserId -> m Ack
deleteV1UserBy:id registrationToken _id = do
  spOpts_' <- ask
  let spOpts_ = case spOpts_' of SPSettings_ o -> o
  let spParams_ = case spOpts_.params of SPParams_ ps_ -> ps_
  let baseURL = spParams_.baseURL
  let httpMethod = "DELETE"
  let queryString = ""
  let reqUrl = baseURL <> "v1" <> "/" <> "user"
        <> "/" <> encodeURLPiece spOpts_' _id <> queryString
  let reqHeaders =
        [{ field : "registrationToken"
         , value : encodeHeader spOpts_' registrationToken
         }]
  let affReq = defaultRequest
                 { method = httpMethod
                 , url = reqUrl
                 , headers = defaultRequest.headers <> reqHeaders
                 }
  affResp <- affjax affReq
  let decodeJson = case spOpts_.decodeJson of SPSettingsDecodeJson_ d -> d
  getResult affReq decodeJson affResp

postV1Quota :: forall eff m.
               MonadAsk (SPSettings_ SPParams_) m => MonadError AjaxError m => MonadAff ( ajax :: AJAX | eff) m
               => Maybe String -> CreateReq -> m CreateRes
postV1Quota registrationToken reqBody = do
  spOpts_' <- ask
  let spOpts_ = case spOpts_' of SPSettings_ o -> o
  let spParams_ = case spOpts_.params of SPParams_ ps_ -> ps_
  let baseURL = spParams_.baseURL
  let httpMethod = "POST"
  let queryString = ""
  let reqUrl = baseURL <> "v1" <> "/" <> "quota" <> queryString
  let reqHeaders =
        [{ field : "registrationToken"
         , value : encodeHeader spOpts_' registrationToken
         }]
  let encodeJson = case spOpts_.encodeJson of SPSettingsEncodeJson_ e -> e
  let affReq = defaultRequest
                 { method = httpMethod
                 , url = reqUrl
                 , headers = defaultRequest.headers <> reqHeaders
                 , content = toNullable <<< Just <<< stringify <<< encodeJson $ reqBody
                 }
  affResp <- affjax affReq
  let decodeJson = case spOpts_.decodeJson of SPSettingsDecodeJson_ d -> d
  getResult affReq decodeJson affResp

putV1QuotaByQuotaId :: forall eff m.
                       MonadAsk (SPSettings_ SPParams_) m => MonadError AjaxError m => MonadAff ( ajax :: AJAX | eff) m
                       => Maybe String -> UpdateReq -> QuotaId -> m UpdateRes
putV1QuotaByQuotaId registrationToken reqBody quotaId = do
  spOpts_' <- ask
  let spOpts_ = case spOpts_' of SPSettings_ o -> o
  let spParams_ = case spOpts_.params of SPParams_ ps_ -> ps_
  let baseURL = spParams_.baseURL
  let httpMethod = "PUT"
  let queryString = ""
  let reqUrl = baseURL <> "v1" <> "/" <> "quota"
        <> "/" <> encodeURLPiece spOpts_' quotaId <> queryString
  let reqHeaders =
        [{ field : "registrationToken"
         , value : encodeHeader spOpts_' registrationToken
         }]
  let encodeJson = case spOpts_.encodeJson of SPSettingsEncodeJson_ e -> e
  let affReq = defaultRequest
                 { method = httpMethod
                 , url = reqUrl
                 , headers = defaultRequest.headers <> reqHeaders
                 , content = toNullable <<< Just <<< stringify <<< encodeJson $ reqBody
                 }
  affResp <- affjax affReq
  let decodeJson = case spOpts_.decodeJson of SPSettingsDecodeJson_ d -> d
  getResult affReq decodeJson affResp

getV1QuotaList :: forall eff m.
                  MonadAsk (SPSettings_ SPParams_) m => MonadError AjaxError m => MonadAff ( ajax :: AJAX | eff) m
                  => Maybe String -> Maybe (Maybe Int) -> Maybe (Maybe Int)
                  -> Maybe EntityType -> Maybe String -> m ListRes
getV1QuotaList registrationToken limit offset entityType entityId = do
  spOpts_' <- ask
  let spOpts_ = case spOpts_' of SPSettings_ o -> o
  let spParams_ = case spOpts_.params of SPParams_ ps_ -> ps_
  let baseURL = spParams_.baseURL
  let httpMethod = "GET"
  let queryArgs = catMaybes [
    encodeQueryItem spOpts_' "limit" <$> limit,
    encodeQueryItem spOpts_' "offset" <$> offset,
    encodeQueryItem spOpts_' "entityType" <$> entityType,
    encodeQueryItem spOpts_' "entityId" <$> entityId
  ]
  let queryString = if null queryArgs then "" else "?" <> (joinWith "&" queryArgs)
  let reqUrl = baseURL <> "v1" <> "/" <> "quota" <> "/" <> "list" <> queryString
  let reqHeaders =
        [{ field : "registrationToken"
         , value : encodeHeader spOpts_' registrationToken
         }]
  let affReq = defaultRequest
                 { method = httpMethod
                 , url = reqUrl
                 , headers = defaultRequest.headers <> reqHeaders
                 }
  affResp <- affjax affReq
  let decodeJson = case spOpts_.decodeJson of SPSettingsDecodeJson_ d -> d
  getResult affReq decodeJson affResp

getV1QuotaBy:id :: forall eff m.
                   MonadAsk (SPSettings_ SPParams_) m => MonadError AjaxError m => MonadAff ( ajax :: AJAX | eff) m
                   => Maybe String -> QuotaId -> m (QuotaT Identity)
getV1QuotaBy:id registrationToken _id = do
  spOpts_' <- ask
  let spOpts_ = case spOpts_' of SPSettings_ o -> o
  let spParams_ = case spOpts_.params of SPParams_ ps_ -> ps_
  let baseURL = spParams_.baseURL
  let httpMethod = "GET"
  let queryString = ""
  let reqUrl = baseURL <> "v1" <> "/" <> "quota"
        <> "/" <> encodeURLPiece spOpts_' _id <> queryString
  let reqHeaders =
        [{ field : "registrationToken"
         , value : encodeHeader spOpts_' registrationToken
         }]
  let affReq = defaultRequest
                 { method = httpMethod
                 , url = reqUrl
                 , headers = defaultRequest.headers <> reqHeaders
                 }
  affResp <- affjax affReq
  let decodeJson = case spOpts_.decodeJson of SPSettingsDecodeJson_ d -> d
  getResult affReq decodeJson affResp

postV1Blacklist :: forall eff m.
                   MonadAsk (SPSettings_ SPParams_) m => MonadError AjaxError m => MonadAff ( ajax :: AJAX | eff) m
                   => Maybe String -> CreateReq -> m CreateRes
postV1Blacklist registrationToken reqBody = do
  spOpts_' <- ask
  let spOpts_ = case spOpts_' of SPSettings_ o -> o
  let spParams_ = case spOpts_.params of SPParams_ ps_ -> ps_
  let baseURL = spParams_.baseURL
  let httpMethod = "POST"
  let queryString = ""
  let reqUrl = baseURL <> "v1" <> "/" <> "blacklist" <> queryString
  let reqHeaders =
        [{ field : "registrationToken"
         , value : encodeHeader spOpts_' registrationToken
         }]
  let encodeJson = case spOpts_.encodeJson of SPSettingsEncodeJson_ e -> e
  let affReq = defaultRequest
                 { method = httpMethod
                 , url = reqUrl
                 , headers = defaultRequest.headers <> reqHeaders
                 , content = toNullable <<< Just <<< stringify <<< encodeJson $ reqBody
                 }
  affResp <- affjax affReq
  let decodeJson = case spOpts_.decodeJson of SPSettingsDecodeJson_ d -> d
  getResult affReq decodeJson affResp

putV1BlacklistByBlacklist_id :: forall eff m.
                                MonadAsk (SPSettings_ SPParams_) m => MonadError AjaxError m => MonadAff ( ajax :: AJAX | eff) m
                                => Maybe String -> UpdateReq -> BlacklistId
                                -> m UpdateRes
putV1BlacklistByBlacklist_id registrationToken reqBody blacklist_id = do
  spOpts_' <- ask
  let spOpts_ = case spOpts_' of SPSettings_ o -> o
  let spParams_ = case spOpts_.params of SPParams_ ps_ -> ps_
  let baseURL = spParams_.baseURL
  let httpMethod = "PUT"
  let queryString = ""
  let reqUrl = baseURL <> "v1" <> "/" <> "blacklist"
        <> "/" <> encodeURLPiece spOpts_' blacklist_id <> queryString
  let reqHeaders =
        [{ field : "registrationToken"
         , value : encodeHeader spOpts_' registrationToken
         }]
  let encodeJson = case spOpts_.encodeJson of SPSettingsEncodeJson_ e -> e
  let affReq = defaultRequest
                 { method = httpMethod
                 , url = reqUrl
                 , headers = defaultRequest.headers <> reqHeaders
                 , content = toNullable <<< Just <<< stringify <<< encodeJson $ reqBody
                 }
  affResp <- affjax affReq
  let decodeJson = case spOpts_.decodeJson of SPSettingsDecodeJson_ d -> d
  getResult affReq decodeJson affResp

getV1BlacklistList :: forall eff m.
                      MonadAsk (SPSettings_ SPParams_) m => MonadError AjaxError m => MonadAff ( ajax :: AJAX | eff) m
                      => Maybe String -> Maybe (Maybe Int) -> Maybe (Maybe Int)
                      -> Maybe EntityType -> Maybe String -> m ListRes
getV1BlacklistList registrationToken limit offset entityType entityId = do
  spOpts_' <- ask
  let spOpts_ = case spOpts_' of SPSettings_ o -> o
  let spParams_ = case spOpts_.params of SPParams_ ps_ -> ps_
  let baseURL = spParams_.baseURL
  let httpMethod = "GET"
  let queryArgs = catMaybes [
    encodeQueryItem spOpts_' "limit" <$> limit,
    encodeQueryItem spOpts_' "offset" <$> offset,
    encodeQueryItem spOpts_' "entityType" <$> entityType,
    encodeQueryItem spOpts_' "entityId" <$> entityId
  ]
  let queryString = if null queryArgs then "" else "?" <> (joinWith "&" queryArgs)
  let reqUrl = baseURL <> "v1" <> "/" <> "blacklist"
        <> "/" <> "list" <> queryString
  let reqHeaders =
        [{ field : "registrationToken"
         , value : encodeHeader spOpts_' registrationToken
         }]
  let affReq = defaultRequest
                 { method = httpMethod
                 , url = reqUrl
                 , headers = defaultRequest.headers <> reqHeaders
                 }
  affResp <- affjax affReq
  let decodeJson = case spOpts_.decodeJson of SPSettingsDecodeJson_ d -> d
  getResult affReq decodeJson affResp

getV1BlacklistBy:id :: forall eff m.
                       MonadAsk (SPSettings_ SPParams_) m => MonadError AjaxError m => MonadAff ( ajax :: AJAX | eff) m
                       => Maybe String -> BlacklistId -> m (BlacklistT Identity)
getV1BlacklistBy:id registrationToken _id = do
  spOpts_' <- ask
  let spOpts_ = case spOpts_' of SPSettings_ o -> o
  let spParams_ = case spOpts_.params of SPParams_ ps_ -> ps_
  let baseURL = spParams_.baseURL
  let httpMethod = "GET"
  let queryString = ""
  let reqUrl = baseURL <> "v1" <> "/" <> "blacklist"
        <> "/" <> encodeURLPiece spOpts_' _id <> queryString
  let reqHeaders =
        [{ field : "registrationToken"
         , value : encodeHeader spOpts_' registrationToken
         }]
  let affReq = defaultRequest
                 { method = httpMethod
                 , url = reqUrl
                 , headers = defaultRequest.headers <> reqHeaders
                 }
  affResp <- affjax affReq
  let decodeJson = case spOpts_.decodeJson of SPSettingsDecodeJson_ d -> d
  getResult affReq decodeJson affResp

deleteV1BlacklistById :: forall eff m.
                         MonadAsk (SPSettings_ SPParams_) m => MonadError AjaxError m => MonadAff ( ajax :: AJAX | eff) m
                         => Maybe String -> BlacklistId -> m Ack
deleteV1BlacklistById registrationToken id = do
  spOpts_' <- ask
  let spOpts_ = case spOpts_' of SPSettings_ o -> o
  let spParams_ = case spOpts_.params of SPParams_ ps_ -> ps_
  let baseURL = spParams_.baseURL
  let httpMethod = "DELETE"
  let queryString = ""
  let reqUrl = baseURL <> "v1" <> "/" <> "blacklist"
        <> "/" <> encodeURLPiece spOpts_' id <> queryString
  let reqHeaders =
        [{ field : "registrationToken"
         , value : encodeHeader spOpts_' registrationToken
         }]
  let affReq = defaultRequest
                 { method = httpMethod
                 , url = reqUrl
                 , headers = defaultRequest.headers <> reqHeaders
                 }
  affResp <- affjax affReq
  let decodeJson = case spOpts_.decodeJson of SPSettingsDecodeJson_ d -> d
  getResult affReq decodeJson affResp

postV1DocumentByEntityTypeByEntityIdUpload :: forall eff m.
                                              MonadAsk (SPSettings_ SPParams_) m => MonadError AjaxError m => MonadAff ( ajax :: AJAX | eff) m
                                              => Maybe String
                                              -> MultipartData Mem
                                              -> DocumentEntity -> String
                                              -> m DocumentRes
postV1DocumentByEntityTypeByEntityIdUpload registrationToken reqBody entityType
                                           entityId = do
  spOpts_' <- ask
  let spOpts_ = case spOpts_' of SPSettings_ o -> o
  let spParams_ = case spOpts_.params of SPParams_ ps_ -> ps_
  let baseURL = spParams_.baseURL
  let httpMethod = "POST"
  let queryString = ""
  let reqUrl = baseURL <> "v1" <> "/" <> "document"
        <> "/" <> encodeURLPiece spOpts_' entityType
        <> "/" <> encodeURLPiece spOpts_' entityId
        <> "/" <> "upload" <> queryString
  let reqHeaders =
        [{ field : "registrationToken"
         , value : encodeHeader spOpts_' registrationToken
         }]
  let encodeJson = case spOpts_.encodeJson of SPSettingsEncodeJson_ e -> e
  let affReq = defaultRequest
                 { method = httpMethod
                 , url = reqUrl
                 , headers = defaultRequest.headers <> reqHeaders
                 , content = toNullable <<< Just <<< stringify <<< encodeJson $ reqBody
                 }
  affResp <- affjax affReq
  let decodeJson = case spOpts_.decodeJson of SPSettingsDecodeJson_ d -> d
  getResult affReq decodeJson affResp

getV1DocumentByEntityTypeByEntityId :: forall eff m.
                                       MonadAsk (SPSettings_ SPParams_) m => MonadError AjaxError m => MonadAff ( ajax :: AJAX | eff) m
                                       => Maybe String -> DocumentByType
                                       -> String -> m (Array ListDocumentRes)
getV1DocumentByEntityTypeByEntityId registrationToken entityType entityId = do
  spOpts_' <- ask
  let spOpts_ = case spOpts_' of SPSettings_ o -> o
  let spParams_ = case spOpts_.params of SPParams_ ps_ -> ps_
  let baseURL = spParams_.baseURL
  let httpMethod = "GET"
  let queryString = ""
  let reqUrl = baseURL <> "v1" <> "/" <> "document"
        <> "/" <> encodeURLPiece spOpts_' entityType
        <> "/" <> encodeURLPiece spOpts_' entityId <> queryString
  let reqHeaders =
        [{ field : "registrationToken"
         , value : encodeHeader spOpts_' registrationToken
         }]
  let affReq = defaultRequest
                 { method = httpMethod
                 , url = reqUrl
                 , headers = defaultRequest.headers <> reqHeaders
                 }
  affResp <- affjax affReq
  let decodeJson = case spOpts_.decodeJson of SPSettingsDecodeJson_ d -> d
  getResult affReq decodeJson affResp

postV1Tag :: forall eff m.
             MonadAsk (SPSettings_ SPParams_) m => MonadError AjaxError m => MonadAff ( ajax :: AJAX | eff) m
             => Maybe String -> CreateReq -> m CreateRes
postV1Tag registrationToken reqBody = do
  spOpts_' <- ask
  let spOpts_ = case spOpts_' of SPSettings_ o -> o
  let spParams_ = case spOpts_.params of SPParams_ ps_ -> ps_
  let baseURL = spParams_.baseURL
  let httpMethod = "POST"
  let queryString = ""
  let reqUrl = baseURL <> "v1" <> "/" <> "tag" <> queryString
  let reqHeaders =
        [{ field : "registrationToken"
         , value : encodeHeader spOpts_' registrationToken
         }]
  let encodeJson = case spOpts_.encodeJson of SPSettingsEncodeJson_ e -> e
  let affReq = defaultRequest
                 { method = httpMethod
                 , url = reqUrl
                 , headers = defaultRequest.headers <> reqHeaders
                 , content = toNullable <<< Just <<< stringify <<< encodeJson $ reqBody
                 }
  affResp <- affjax affReq
  let decodeJson = case spOpts_.decodeJson of SPSettingsDecodeJson_ d -> d
  getResult affReq decodeJson affResp

getV1TagByEntityTypeByEntityIdList :: forall eff m.
                                      MonadAsk (SPSettings_ SPParams_) m => MonadError AjaxError m => MonadAff ( ajax :: AJAX | eff) m
                                      => Maybe String -> String -> String
                                      -> m ListRes
getV1TagByEntityTypeByEntityIdList registrationToken entityType entityId = do
  spOpts_' <- ask
  let spOpts_ = case spOpts_' of SPSettings_ o -> o
  let spParams_ = case spOpts_.params of SPParams_ ps_ -> ps_
  let baseURL = spParams_.baseURL
  let httpMethod = "GET"
  let queryString = ""
  let reqUrl = baseURL <> "v1" <> "/" <> "tag"
        <> "/" <> encodeURLPiece spOpts_' entityType
        <> "/" <> encodeURLPiece spOpts_' entityId
        <> "/" <> "list" <> queryString
  let reqHeaders =
        [{ field : "registrationToken"
         , value : encodeHeader spOpts_' registrationToken
         }]
  let affReq = defaultRequest
                 { method = httpMethod
                 , url = reqUrl
                 , headers = defaultRequest.headers <> reqHeaders
                 }
  affResp <- affjax affReq
  let decodeJson = case spOpts_.decodeJson of SPSettingsDecodeJson_ d -> d
  getResult affReq decodeJson affResp

postV1TagEntity :: forall eff m.
                   MonadAsk (SPSettings_ SPParams_) m => MonadError AjaxError m => MonadAff ( ajax :: AJAX | eff) m
                   => Maybe String -> TagEntityReq -> m TagEntityRes
postV1TagEntity registrationToken reqBody = do
  spOpts_' <- ask
  let spOpts_ = case spOpts_' of SPSettings_ o -> o
  let spParams_ = case spOpts_.params of SPParams_ ps_ -> ps_
  let baseURL = spParams_.baseURL
  let httpMethod = "POST"
  let queryString = ""
  let reqUrl = baseURL <> "v1" <> "/" <> "tag" <> "/" <> "entity" <> queryString
  let reqHeaders =
        [{ field : "registrationToken"
         , value : encodeHeader spOpts_' registrationToken
         }]
  let encodeJson = case spOpts_.encodeJson of SPSettingsEncodeJson_ e -> e
  let affReq = defaultRequest
                 { method = httpMethod
                 , url = reqUrl
                 , headers = defaultRequest.headers <> reqHeaders
                 , content = toNullable <<< Just <<< stringify <<< encodeJson $ reqBody
                 }
  affResp <- affjax affReq
  let decodeJson = case spOpts_.decodeJson of SPSettingsDecodeJson_ d -> d
  getResult affReq decodeJson affResp

postV1Comment :: forall eff m.
                 MonadAsk (SPSettings_ SPParams_) m => MonadError AjaxError m => MonadAff ( ajax :: AJAX | eff) m
                 => Maybe String -> CreateReq -> m CreateRes
postV1Comment registrationToken reqBody = do
  spOpts_' <- ask
  let spOpts_ = case spOpts_' of SPSettings_ o -> o
  let spParams_ = case spOpts_.params of SPParams_ ps_ -> ps_
  let baseURL = spParams_.baseURL
  let httpMethod = "POST"
  let queryString = ""
  let reqUrl = baseURL <> "v1" <> "/" <> "comment" <> queryString
  let reqHeaders =
        [{ field : "registrationToken"
         , value : encodeHeader spOpts_' registrationToken
         }]
  let encodeJson = case spOpts_.encodeJson of SPSettingsEncodeJson_ e -> e
  let affReq = defaultRequest
                 { method = httpMethod
                 , url = reqUrl
                 , headers = defaultRequest.headers <> reqHeaders
                 , content = toNullable <<< Just <<< stringify <<< encodeJson $ reqBody
                 }
  affResp <- affjax affReq
  let decodeJson = case spOpts_.decodeJson of SPSettingsDecodeJson_ d -> d
  getResult affReq decodeJson affResp

getV1CommentByPrimaryEntityTypeByPrimaryEntityIdList :: forall eff m.
                                                        MonadAsk (SPSettings_ SPParams_) m => MonadError AjaxError m => MonadAff ( ajax :: AJAX | eff) m
                                                        => Maybe String
                                                        -> String -> String
                                                        -> m ListRes
getV1CommentByPrimaryEntityTypeByPrimaryEntityIdList registrationToken
                                                     primaryEntityType
                                                     primaryEntityId = do
  spOpts_' <- ask
  let spOpts_ = case spOpts_' of SPSettings_ o -> o
  let spParams_ = case spOpts_.params of SPParams_ ps_ -> ps_
  let baseURL = spParams_.baseURL
  let httpMethod = "GET"
  let queryString = ""
  let reqUrl = baseURL <> "v1" <> "/" <> "comment"
        <> "/" <> encodeURLPiece spOpts_' primaryEntityType
        <> "/" <> encodeURLPiece spOpts_' primaryEntityId
        <> "/" <> "list" <> queryString
  let reqHeaders =
        [{ field : "registrationToken"
         , value : encodeHeader spOpts_' registrationToken
         }]
  let affReq = defaultRequest
                 { method = httpMethod
                 , url = reqUrl
                 , headers = defaultRequest.headers <> reqHeaders
                 }
  affResp <- affjax affReq
  let decodeJson = case spOpts_.decodeJson of SPSettingsDecodeJson_ d -> d
  getResult affReq decodeJson affResp

